import os
import uvicorn

from dotenv import load_dotenv
from fastapi import FastAPI, Request, HTTPException, Header
from pydantic import BaseModel

from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.webhooks import MessageEvent, TextMessageContent
from linebot.v3.messaging import (
    ApiClient,
    MessagingApi,
    Configuration,
    ReplyMessageRequest,
    PushMessageRequest,
    TextMessage,
)

from .response_message import generate_reply_message
from .retrieval_utils import ask_question_to_rag, store_user_response, store_user_question, check_and_update_question_limit
from .content_filter import check_content_safety

app = FastAPI()

load_dotenv(override=True)

def get_secret_value(secret_name, default=None):
    secret_path = f"/secrets/{secret_name}"
    if os.path.exists(secret_path):
        with open(secret_path, "r") as f:
            return f.read().strip()
    return os.getenv(secret_name, default)

get_access_token = get_secret_value('LINE_CHANNEL_ACCESS_TOKEN')
get_channel_secret = get_secret_value('LINE_CHANNEL_SECRET')
print(f"LINE_CHANNEL_SECRET: {get_channel_secret}")

configuration = Configuration(access_token=get_access_token)
handler = WebhookHandler(channel_secret=get_channel_secret)

@app.post("/callback")
async def callback(request: Request, x_line_signature: str = Header(None)):
    body = await request.body()
    body_str = body.decode('utf-8')
    print(f"Received body: {body_str}")

    try:
        handler.handle(body_str, x_line_signature)
    except InvalidSignatureError:
        print("Invalid signature. Please check your channel access token/channel secret.")
        raise HTTPException(status_code=400, detail="Invalid signature.")

    return 'OK'

@handler.add(MessageEvent, message=TextMessageContent)
def on_message_event(event: MessageEvent):
    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)

        # ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ push ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
        try:
            # ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏à‡πâ‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
            processing_msg = TextMessage(text="‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏≠‡∏¢‡∏π‡πà... ‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡∏Ñ‡πà‡∏∞")
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[processing_msg]
                )
            )
        except Exception:
            # ‡∏ñ‡πâ‡∏≤‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡πÑ‡∏õ
            pass

        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏•‡πâ‡∏ß push ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏£‡πâ‡∏≠‡∏°
        final_message = generate_reply_message(event)
        if not final_message:
            return None

        try:
            user_id = event.source.user_id if event.source and hasattr(event.source, 'user_id') else None
            if user_id:
                line_bot_api.push_message(
                    PushMessageRequest(
                        to=user_id,
                        messages=[final_message]
                    )
                )
        except Exception:
            # ‡∏´‡∏≤‡∏Å push ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏•‡πâ‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏á‡∏≤‡∏ô
            pass


# ------------------------
# ‚úÖ RAG Endpoint /ask
# ------------------------
class AskRequest(BaseModel):
    user_id: str
    question: str

@app.post("/ask")
async def ask_route(req: AskRequest):
    # üõ°Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏Å‡πà‡∏≠‡∏ô
    is_safe, safety_message = check_content_safety(req.question)
    if not is_safe:
        print(f"üö´ Content filtered for user {req.user_id}: {safety_message}")
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏ô user_profiles
        store_user_question(
            question=req.question,
            user_id=req.user_id,
            context_data={"endpoint": "/ask", "filtered": True}
        )
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÉ‡∏ô collection astrobot
        store_user_response(
            question=req.question,
            answer=safety_message,
            user_id=req.user_id,
            response_type="content_filtered",
            context_data={"filter_reason": "unsafe_content", "endpoint": "/ask"}
        )
        
        return {"answer": safety_message}
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á)
    is_allowed, current_count, limit_message = check_and_update_question_limit(req.user_id)
    if not is_allowed:
        print(f"üö´ Question limit exceeded for user {req.user_id}: {current_count}/3")
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏ô user_profiles
        store_user_question(
            question=req.question,
            user_id=req.user_id,
            context_data={"endpoint": "/ask", "limit_exceeded": True}
        )
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÉ‡∏ô collection astrobot
        store_user_response(
            question=req.question,
            answer=limit_message,
            user_id=req.user_id,
            response_type="question_limit_exceeded",
            context_data={"question_count": current_count, "max_questions": 3, "endpoint": "/ask"}
        )
        
        return {"answer": limit_message}
    
    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏ô user_profiles
    store_user_question(
        question=req.question,
        user_id=req.user_id,
        context_data={"endpoint": "/ask"}
    )
    
    answer = ask_question_to_rag(req.question, req.user_id)
    
    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÉ‡∏ô collection astrobot (ask_question_to_rag ‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• endpoint)
    store_user_response(
        question=req.question,
        answer=answer,
        user_id=req.user_id,
        response_type="api_response",
        context_data={"endpoint": "/ask"}
    )
    
    return {"answer": answer}

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
